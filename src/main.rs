#[path = "gen/schema_capnp.rs"]
#[rustfmt::skip]
#[allow(clippy::all)]
pub mod schema;

use base64::Engine;
use chrono::{Datelike, NaiveDate};
use std::fmt::Display;

/// Entities that implement the trait can be serialized to O, a generated by capnp object.
pub trait CnpPackableTo<O: ::capnp::traits::OwnedStruct>
where
    Self: Sized,
{
    fn pack(&self, builder: O::Builder<'_>);
    fn unpack(reader: &O::Reader<'_>) -> Option<Self>;

    fn pack_array(items: &[Self], mut builder: ::capnp::struct_list::Builder<'_, O>) {
        for (i, item) in items.iter().enumerate() {
            item.pack(builder.reborrow().get(i as u32));
        }
    }

    fn unpack_array(
        reader: ::capnp::Result<::capnp::struct_list::Reader<'_, O>>,
    ) -> Option<Vec<Self>> {
        let reader = reader.ok()?;
        let mut out = Vec::<Self>::with_capacity(reader.len() as usize);
        for in_item in reader.iter() {
            out.push(Self::unpack(&in_item)?);
        }
        Some(out)
    }
}

// Example of a struct that can be packed into a corresponding capnp object.
#[derive(PartialEq, Eq)]
pub struct DatesRange {
    pub since: NaiveDate,
    pub till: NaiveDate,
}

impl Display for DatesRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{}; {}]", self.since, self.till)
    }
}

impl CnpPackableTo<schema::dates_range::Owned> for DatesRange {
    fn pack(&self, mut builder: schema::dates_range::Builder) {
        builder.set_since(self.since.num_days_from_ce());
        builder.set_till(self.till.num_days_from_ce());
    }

    fn unpack(reader: &schema::dates_range::Reader) -> Option<Self> {
        let since = NaiveDate::from_num_days_from_ce_opt(reader.get_since())?;
        let till = NaiveDate::from_num_days_from_ce_opt(reader.get_till())?;

        if since >= till {
            return None;
        }
        Some(DatesRange { since, till })
    }
}

pub trait EncodableToB64
where
    Self: Sized,
{
    fn encode_to_b64(&self) -> Option<String>;
    fn decode_from_b64(encoded: String) -> Option<Self>;
}

#[cfg(not(debug_assertions))]
impl EncodableToB64 for DatesRange {
    fn encode_to_b64(&self) -> Option<String> {
        let mut message = ::capnp::message::Builder::new_default();
        let builder = message.init_root();
        self.pack(builder);
        let mut buffer = Vec::<u8>::new();
        ::capnp::serialize::write_message(&mut buffer, &message).ok()?;
        Some(::base64::engine::general_purpose::STANDARD.encode(&buffer))
    }

    fn decode_from_b64(encoded: String) -> Option<Self> {
        let buffer = ::base64::engine::general_purpose::STANDARD
            .decode(encoded)
            .ok()?;

        let msg = ::capnp::serialize::read_message(
            buffer.as_slice(),
            ::capnp::message::ReaderOptions::new(),
        )
        .ok()?;
        let reader = msg.get_root().ok()?;
        Self::unpack(&reader)
    }
}

#[cfg(debug_assertions)]
impl<O, T> EncodableToB64 for T
where
    T: CnpPackableTo<O>,
    O: ::capnp::traits::OwnedStruct,
{
    fn encode_to_b64(&self) -> Option<String> {
        let mut message = ::capnp::message::Builder::new_default();
        let builder = message.init_root();
        self.pack(builder);
        let mut buffer = Vec::<u8>::new();
        ::capnp::serialize::write_message(&mut buffer, &message).ok()?;
        Some(::base64::engine::general_purpose::STANDARD.encode(&buffer))
    }

    fn decode_from_b64(_encoded: String) -> Option<Self> {
        let buffer = ::base64::engine::general_purpose::STANDARD
            .decode(encoded)
            .ok()?;

        let msg = ::capnp::serialize::read_message(
            buffer.as_slice(),
            ::capnp::message::ReaderOptions::new(),
        )
        .ok()?;
        let reader = msg.get_root().ok()?;
        Self::unpack(&reader)
    }
}

fn main() {
    let original = DatesRange {
        since: NaiveDate::MIN,
        till: NaiveDate::MAX,
    };
    let decoded = DatesRange::decode_from_b64(original.encode_to_b64().expect("Failed to encode"))
        .expect("Failed to decode");
    if decoded == original {
        println!("Good job!");
    } else {
        panic!("Oops");
    }
}
